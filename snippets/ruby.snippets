## headers

snippet #!
abbr    #!/usr/bin/env ruby
options head
	#!/usr/bin/env ruby
	# frozen_string_literal: true
	${0}

snippet #frozen
options head
	# frozen_string_literal: true
	${0}


## statements

snippet ife
	if ${1:#:condition}
		${2}
	else
		${3}
	end

snippet if2
	if ${1:#:condition}
		${2}
	elsif ${3:#:condition}
		${4}
	end

snippet if3
	if ${1:#:condition}
		${2}
	elsif ${3:#:condition}
		${4}
	else
		${5}
	end

snippet elsif
	elsif ${1:#:condition}
		${0}

snippet case
options word
	case ${1}
	when ${2}
		${3}
	else
		${4:raise}
	end

snippet when
options word
	when ${1}
		${0}

snippet defs
options head
	def self.${1:#:class_method_name}
		${2}
	end

snippet rescue
options head
	rescue StandardError => e

snippet lambda
alias lam
options word
	->(${1}){ ${2} }

snippet lambda-keyword
options word
	lambda{|${1}| ${2} }


## class

snippet class
alias cl
options head
	class ${1:`FilenameMixedcase()`}
		${0}
	end

snippet class-initialize
alias cli
options head
	class ${1:`FilenameMixedcase()`}
		def initialize(${2})
			${3}
		end${0}
	end

snippet class-methods
alias clm
options head
	class << self
		def ${1}
			${0}
		end
	end

snippet class-error
alias cle
options head
	class ${1:`FilenameMixedcase()`} < StandardError
		def initialize(${2})
			super(${3:$2})${0}
		end
	end

snippet class-error-graphql
alias cleg
options head
	class ${1:`FilenameMixedcase()`} < GraphQL::ExecutionError
		def initialize(${2})
			super(${3:$2})${0}
		end
	end

snippet class-delegate
options head
alias cld
abbr class .. < DelegateClass .. initialize .. end
	class ${1:`FilenameMixedcase()`} < DelegateClass(${2:#:ParentClass})
		def initialize(${3})
			super(${4})${0}
		end
	end

snippet def-initialize
alias init
options head
	def initialize(${1})
		${0}
	end

snippet attr_reader
alias attrr
options head
	attr_reader :${1:attr_names}

snippet attr_writer
alias attrw
options head
	attr_writer :${1:attr_names}

snippet attr_accessor
alias attra
options head
	attr_accessor :${1:attr_names}

snippet def_delegator
alias defd
options head
	def_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}

snippet def_delegators
alias defds
options head
	def_delegators :${1:@del_obj}, :${2:del_methods}


## module

snippet module
alias md
options head
	module ${1:`FilenameMixedcase()`}
		${0}
	end

snippet module-with-function
alias mdwf
options head
	module ${1:`FilenameMixedcase()`}
		module_function
		${0}
	end

snippet module_function
alias mdf
options head
	module_function


## method

snippet alias_method
options head
	alias_method :${1:new_name}, :${2:old_name}

snippet def-method_missing
alias defmm
options head
	def method_missing(meth, *args, &blk)
		${0}
	end



## shorthands

snippet =begin
options word
	=begin
		${0}
	=end

snippet END
options word
	__END__

snippet verbose
options word
	$VERBOSE = (ENV['DEBUG'].to_i == 0)? nil : true
	${0}

snippet deep_copy
options word
	Marshal.load(Marshal.dump(${1}))${0}

snippet json-parse-symbol
options word
alias jsps
	JSON.parse(${1}, { symbolize_names: true })${0}

snippet inject
options word
	inject(${1:init}){|${2:memo}, ${3:obj}| ${4} }

snippet each_with_index
alias ewi
options word
	each_with_index {|${1}| ${0} }

snippet each_with_object
alias ewo
	each_with_object(${1}) {|${2:value}, ${3:memo}| ${0} }

snippet gen-array-nest
	Array.new(${1:size}) { Array.new(${2:size}) }


## debug helper

snippet pretty_inspect
alias pi
	pretty_inspect

snippet taputs
	.tap(&method(:puts))${0}

snippet tapp
	.tap(&method(:pp))${0}

snippet mylog
	File.open('mylog', 'w') {|f| f.puts ${0} }

snippet marshal-dump-file
	File.open(${1:"path/to/file.dump"}, "wb"){|${2:file}| Marshal.dump(${3:obj}, $2) }${4}

snippet marshal-load-file
	File.open(${1:"path/to/file.dump"}, "rb"){|${2:file}| Marshal.load($2) }${3}

snippet irb
	require 'irb'; binding.irb
	puts '[*] end binding'

snippet pry
	require 'pry'; binding.pry
	puts '[*] end binding'

snippet debug
	rescue => e # TODO debug
		puts e.message, e.backtrace
	ensure
		binding.irb

snippet debug-file
	rescue => e
		File.open('tmp/error', 'a'){|file| file.write(e)}


## Rubocop

snippet rubocop-disable-range
	# rubocop:disable ${1}
	${0}
	# rubocop:enable $1

snippet rubocop-disable-line
abbr rubocop-disable-line(rcd)
alias rcd
	# rubocop:disable ${0}


## Rails

snippet log
	Rails.logger.debug ${0}

snippet log-
	Rails.logger.debug "---------- ${0}".red

snippet logm
	Rails.logger.debug "---------- called: #{self}.#{__method__} L#{__LINE__}".red${0}

snippet create_table
	create_table ${1}, id: :uuid do |t|
		${0}
	end

## RSpec

snippet irb-rspec
	after(:each) do |example|
		require 'irb'; binding.irb
		puts '[*] end binding'
	end

## Rake

snippet tas
	desc "${1:Task description\}"
	task :${2:task_name => [:dependent, :tasks]} do
		${0}
	end


## assert

snippet as
	assert(${1:test}, "${2:Failure message.}")${3}
snippet ase
	assert_equal(${1:expected}, ${2:actual})${3}
snippet asne
	assert_not_equal(${1:unexpected}, ${2:actual})${3}
snippet asid
	assert_in_delta(${1:expected_float}, ${2:actual_float}, ${3:2 ** -20})${4}
snippet asio
	assert_instance_of(${1:ExpectedClass}, ${2:actual_instance})${3}
snippet asko
	assert_kind_of(${1:ExpectedKind}, ${2:actual_instance})${3}
snippet asn
	assert_nil(${1:instance})${2}
snippet asnn
	assert_not_nil(${1:instance})${2}
snippet asm
	assert_match(/${1:expected_pattern}/, ${2:actual_string})${3}
snippet asnm
	assert_no_match(/${1:unexpected_pattern}/, ${2:actual_string})${3}
snippet aso
	assert_operator(${1:left}, :${2:operator}, ${3:right})${4}
snippet asr
	assert_raise(${1:Exception}){ ${2} }
snippet asnr
	assert_nothing_raised(${1:Exception}){ ${2} }
snippet asrt
	assert_respond_to(${1:object}, :${2:method})${3}
snippet asns
	assert_not_same(${1:unexpected}, ${2:actual})${3}
snippet ast
	assert_throws(:${1:expected}){ ${2} }
snippet asnt
	assert_nothing_thrown{ ${1} }


## utils

snippet script_dir
	__dir__

snippet getints
	gets.split.map(&:to_i)${0}

# unix filter{}
snippet argf
alias unif
	ARGF.each_line${1} do |${2:line}|
		${0}
	end

snippet usage
	if ARGV.${1}
		abort "Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${3}
	end

snippet fileopen
alias open
abbr File.open(filename) do ... end
	File.open(${1:#:filename}, '${2:#:mode}') do |${3:file}|
		${0}
	end

snippet urlencode
#	require 'erb'
	ERB::Util.url_encode(${1})

snippet main
options head
	if __FILE__ == \$0
		${0}
	end

snippet glob
options head
	Dir.glob(${1:'**/*'}) do |name|
		${0}
	end

snippet optp
options head
	require "optparse"

	options = {${1:default => "args"}}

	ARGV.options do |opts|
		opts.banner = "Usage: #{File.basename($PROGRAM_NAME)}
	end

snippet opt
	opts.on( "-${1}", "--${2:long-option-name}", ${3:String}, "${4:Option description.}") do |${5:opt}|
		${6}
	end


## define helper methods

snippet def-deep_copy
	def deep_copy(obj)
		Marshal.load(Marshal.dump(obj))
	end

snippet def-int?
	class String
		def int?
			Integer(self) && true rescue false
		end
	end
	${0}

snippet def-puts_color
	def puts_color(color_num, str)
		puts "\e[38;5;#{color_num}m#{str}\e[00m"
	end

snippet def-capture_stdout
	def capture_stdout
		$stdout = out = StringIO.new
		yield
		return out.string
	ensure
		$stdout = STDOUT
	end

snippet def-pager
	def pager
		$stdout = out = StringIO.new
		return yield
	ensure
		$stdout = STDOUT
		opt='--RAW-CONTROL-CHARS --quit-if-one-screen --no-init'
		IO.popen(['less', opt], 'w'){|f| f.puts out.string }
	end


## pwn

snippet pwn
options head
	#!/usr/bin/env ruby
	# coding: ascii-8bit
	require 'upwn'
	include Shellcode

	class Solver
	end

	host = true ? 'localhost' : ''
	port = ${1:8888}

	sl = Solver.open(host, port)
	${0}

	require 'irb'; binding.irb
	puts '[*] end binding'

	=begin
	=end


## 未振り分け
