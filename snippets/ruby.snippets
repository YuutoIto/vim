snippet #!
abbr    #!/usr/bin/env ruby
alias   shebang
options head
  #!/usr/bin/env ruby
  ${0}


# basic {{{

snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	end

snippet if2
	if ${1:condition}
		${2}
  elsif ${3:condition}
    ${4}
	end

snippet if3
	if ${1:condition}
		${2}
  elsif ${3:condition}
    ${4}
	else
		${5}
	end

snippet elsif
	elsif ${1:condition}
		${0}

snippet when
	when ${1:condition}
		${0}

snippet while
	while ${1:condition}
		${0}
	end

snippet loo
	loop{ ${1} }

snippet until
	until ${1:condition}
		${0}
	end

snippet req
	require "${1}"${0}

snippet abort
  abort "${1}"${0}

#}}}

snippet defs
	def self.${1:class_method_name}
		${2}
	end

snippet deft
	def test_${1:case_name}
		${0}
	end

snippet method_missing
alias defmm
	def method_missing(meth, *args, &blk)
		${1}
	end

snippet defd
	def_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}

snippet defds
	def_delegators :${1:@del_obj}, :${2:del_methods}

snippet alias_method
alias am
	alias_method :${1:new_name}, :${2:old_name}

snippet r
	attr_reader :${1:attr_names}
snippet w
	attr_writer :${1:attr_names}
snippet rw
	attr_accessor :${1:attr_names}

snippet clai
abbr class .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		def initialize(${2:args})
			${3}
		end${0}
	end

snippet singleton
snippet sinc
	class << self; self end

snippet =begin
alias =b
	=begin
		${0}
	=end

snippet end
	__END__


# pwn #{{{
snippet pwn
  #!/usr/bin/env ruby
  # coding: ascii-8bit
  require 'upwn'
  include Shellcode

  class Solver
  end

  host = true ? 'localhost' : ''
  port = ${1:8888}

  sl = Solver.open(host, port)
  ${0}

  require 'pry'; binding.pry; puts '[*] end binding'

  =begin
  =end
#}}}

snippet verbose
  $VERBOSE = (ENV['DEBUG'].to_i == 0)? nil : true
  ${0}

snippet getints
  gets.split.map &:to_i
  ${0}

# unix filter{}
snippet argf
alias unif
	ARGF.each_line${1} do |${2:line}|
		${0}
	end

snippet arraytwo
  Array.new(${1:size}){|e| Array.new(${2:size}) }

snippet pry
	require 'pry'; binding.pry; puts '[*] end binding'

snippet debug
  rescue => e # TODO debug
    puts e.message, e.backtrace
  ensure
    binding.pry

snippet deep_copy
	Marshal.load(Marshal.dump(${1:obj_to_copy}))${0}

snippet debug-out
	rescue => e
		File.open('tmp/error', 'a'){|file| file.write(e)}

snippet pry-rspec
	after(:each) do |example|
		require 'pry'; binding.pry
	end

# define #{{{

snippet def-deep_copy
  def deep_copy(obj)
    Marshal.load(Marshal.dump(obj))
  end

snippet def-int?
  class String
    def int?
      Integer(self) && true rescue false
    end
  end
  ${0}

snippet def-puts_color
  def puts_color(color_num, str)
    puts "\e[38;5;#{color_num}m#{str}\e[00m"
  end

snippet def-capture_stdout
  def capture_stdout
    $stdout = out = StringIO.new
    yield
    return out.string
  ensure
    $stdout = STDOUT
  end

snippet def-pager
  def pager
    $stdout = out = StringIO.new
    return yield
  ensure
    $stdout = STDOUT
    opt='--RAW-CONTROL-CHARS --quit-if-one-screen --no-init'
    IO.popen(['less', opt], 'w'){|f| f.puts out.string }
  end
#}}}

snippet Enum
	include Enumerable

	def each(&block)
		${1}
	end

snippet Comp
	include Comparable

	def <=>(other)
		${1}
	end

snippet Forw-
	extend Forwardable


# misc

snippet mylog
	File.open('mylog', 'w') do |f|
		f.puts ${0}
	end

snippet pretty_inspect
alias pi
	pretty_inspect

# ---------- on hold ----------

# Marshal.dump(.., file)
snippet Md
	File.open(${1:"path/to/file.dump"}, "wb"){|${2:file}| Marshal.dump(${3:obj}, $2) }${4}
# Mashal.load(obj)
snippet Ml
	File.open(${1:"path/to/file.dump"}, "rb"){|${2:file}| Marshal.load($2) }${3}
snippet Pn-
	PStore.new(${1:"file_name.pstore"})${2}

# option_parse{}
snippet optp
	require "optparse"

	options = {${1:default => "args"}}

	ARGV.options do |opts|
		opts.banner = "Usage: #{File.basename($PROGRAM_NAME)}
  end

snippet opt
	opts.on( "-${1}", "--${2:long-option-name}", ${3:String}, "${4:Option description.}") do |${5:opt}|
		${6}
	end


# ---------- 後回し ----------

# class and module {{{
snippet cla
abbr ClassName = Struct .. do .. end
	${1:`substitute(Filename(), '^.', '\u&', '')`} = Struct.new(:${2:attr_names}) do
		def ${3:method_name}
			${4}
		end
    ${0}
	end

# class .. < DelegateClass .. initialize .. end
snippet cla-
	class ${1:`substitute(Filename(), '^.', '\u&', '')`} < DelegateClass(${2:ParentClass})
		def initialize(${3:args})
			super(${4:del_obj})

			${5}
		end
	end

snippet mod module .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end

# snippet mod module .. module_function .. end
# 	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
# 		module_function
#
# 		${2}
# 	end

#}}}

# usage_if()
snippet usage
	if ARGV.${1}
		abort "Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${3}
	end

snippet array
	Array.new(${1:10}){|${2:i}| ${3} }
snippet hash
	Hash.new{|${1:hash}, ${2:key}| $1[$2] = ${3} }
snippet Dir Dir.global(){|file| .. }
	Dir.glob(${1:"dir/glob/*"}){|${2:file}| ${3} }
snippet dir
	Filename.dirname(__FILE__)
snippet deli
	delete_if{|${1:e}| ${2} }
snippet fil
	fill(${1:range}){|${2:i}| ${3} }
# flatten_once()
snippet flao
	inject(Array.new){|${1:arr}, ${2:a}| $1.push(*$2)}${3}
snippet zip
	zip(${1:enums}){|${2:row}| ${3} }
# downto(0){|n| .. }
snippet dow
	downto(${1:0}){|${2:n}| ${3} }
snippet ste
	step(${1:2}){|${2:n}| ${3} }
snippet tim
	times{|${1:n}| ${2} }
snippet upt
	upto(${1:1.0/0.0}){|${2:n}| ${3} }

# snippet eac- each_char{|chr| .. }
# 	each_char{|${1:chr}| ${2} }
#
# snippet eac- each_cons(..){|group| .. }
# 	each_cons(${1:2}){|${2:group}| ${3} }

snippet eas-
	each_slice(${1:2}){|${2:group}| ${3} }
snippet reve
	reverse_each{|${1:e}| ${2} }
snippet inj
	inject(${1:init}){|${2:memo}, ${3:obj}| ${4} }

snippet mapwi-
	enum_with_index.map{|${1:e}, ${2:i}| ${3} }
snippet sor
	sort{|a, b| ${1} }
snippet sorb
	sort_by{|${1:e}| ${2} }
snippet ran
	sort_by{ rand }
snippet all
	all?{|${1:e}| ${2} }
snippet any
	any?{|${1:e}| ${2} }
snippet cl
	classify{|${1:e}| ${2} }
snippet col
	collect{|${1:e}| ${2} }
snippet det
	detect{|${1:e}| ${2} }
snippet fet
	fetch(${1:name}){|${2:key}| ${3} }
snippet fin
	find{|${1:e}| ${2} }
snippet fina
	find_all{|${1:e}| ${2} }
snippet gre
	grep(${1:/pattern/}){|${2:match}| ${3} }
snippet sub
	${1:g}sub(${2:/pattern/}){|${3:match}| ${4} }
snippet sca
	scan(${1:/pattern/}){|${2:match}| ${3} }
snippet max
	max{|a, b|, ${1} }
snippet min
	min{|a, b|, ${1} }
snippet par
	partition{|${1:e}|, ${2} }
snippet rej
	reject{|${1:e}|, ${2} }
snippet sel
	select{|${1:e}|, ${2} }

snippet ope
	open(${1:"path/or/url/or/pipe"}, "${2:w}"){|${3:io}| ${4} }

# path_from_here()
snippet patfh
	File.join(File.dirname(__FILE__), *%2[${1:rel path here}])${2}

snippet tc
	require "test/unit"

	require "${1:library_file_name}"

	class Test${2:$1} < Test::Unit::TestCase
		def test_${3:case_name}
			${4}
		end
	end

snippet ts
	require "test/unit"

	require "tc_${1:test_case_file}"
	require "tc_${2:test_case_file}"${3}

# assert {{{
snippet as
	assert(${1:test}, "${2:Failure message.}")${3}
snippet ase
	assert_equal(${1:expected}, ${2:actual})${3}
snippet asne
	assert_not_equal(${1:unexpected}, ${2:actual})${3}
snippet asid
	assert_in_delta(${1:expected_float}, ${2:actual_float}, ${3:2 ** -20})${4}
snippet asio
	assert_instance_of(${1:ExpectedClass}, ${2:actual_instance})${3}
snippet asko
	assert_kind_of(${1:ExpectedKind}, ${2:actual_instance})${3}
snippet asn
	assert_nil(${1:instance})${2}
snippet asnn
	assert_not_nil(${1:instance})${2}
snippet asm
	assert_match(/${1:expected_pattern}/, ${2:actual_string})${3}
snippet asnm
	assert_no_match(/${1:unexpected_pattern}/, ${2:actual_string})${3}
snippet aso
	assert_operator(${1:left}, :${2:operator}, ${3:right})${4}
snippet asr
	assert_raise(${1:Exception}){ ${2} }
snippet asnr
	assert_nothing_raised(${1:Exception}){ ${2} }
snippet asrt
	assert_respond_to(${1:object}, :${2:method})${3}
snippet asns
	assert_not_same(${1:unexpected}, ${2:actual})${3}
snippet ast
	assert_throws(:${1:expected}){ ${2} }
snippet asnt
	assert_nothing_thrown{ ${1} }
#}}}

snippet fl
	flunk("${1:Failure message.}")${2}

# Benchmark.bmbm do .. end
snippet bm-
	TESTS = ${1:10_000}
	Benchmark.bmbm do |results|
		${2}
	end

snippet rep
	results.report("${1:name}:"){ TESTS.times{ ${2} }}


snippet tra
	transaction(${1:true}){ ${2} }
# xmlread(..)
snippet xml-
	REXML::Document.new(File.read(${1:"path/to/file"}))${2}
# xpath(..){ .. }
snippet xpa
	elements.each(${1:"//Xpath"}) do |${2:node}|
		${3}
	end

# class_from_name()
snippet clafn
	split("::").inject(Object){|par, const| par.const_get(const) }

snippet nam
	namespace :${1:`Filename()`} do
		${2}
	end

snippet tas
	desc "${1:Task description\}"
	task :${2:task_name => [:dependent, :tasks]} do
		${3}
	end

snippet     defrescue
alias       defr
abbr        def ... rescue ... end
  def ${1:#:method_name}
    ${2:TARGET}
  rescue ${3:StandardError} => ${4:e}
    ${5}
  end

snippet     do
abbr        do ... end
  do
    ${0}
  end

snippet     dov
abbr        do |var| ... end
  do |${1:var}|
    ${0}
  end

snippet     block
abbr        { ... }
  {
    ${1:TARGET}
  }

snippet     blockvar
abbr        {|var| ... }
  {|${1:var}| ${0} }

snippet     fileopen
alias       open
abbr        File.open(filename) do ... end
  File.open(${1:#:filename}, '${2:#:mode}') do |${3:io}|
    ${0:TARGET}
  end

snippet     edn
abbr        => end?
  end

snippet     urlencode
  # coding: utf-8
  require 'erb'
  puts ERB::Util.url_encode '${1}'

snippet encoding
alias   enc
  # coding: utf-8
  ${0}

snippet each
options word
  each do |${1:var}|
    ${0}
  end

snippet each_byte
alias eab
options word
  each_byte{|${1:var}| ${2} }

snippet each_char
options word
  each_char{|${1:var}| ${2} }

snippet each_index
alias eai
options word
  each_index{|${1:var}| ${2} }

snippet each_key
alias eak
options word
  each_key{|${1:var}| ${2} }

snippet each_value
alias eav
options word
	each_value{|${1:val}| ${2} }

snippet each_line
alias eal
options word
  each_line{|${1:var}| ${2} }

snippet each_with_index
alias eawi
options word
  each_with_index{|${1:var}| ${2} }

snippet each_with_object
alias eawo
	each_with_object{|${1:obj}, ${2:memo}| ${3} }

snippet each_pair
alias eap
options word
  each_pair{|${1:key}, ${2:value}| ${3} }

snippet each_pair_do
alias eapd
options word
  each_pair do |${1:key}, ${2:value}|
    ${3}
  end

snippet map
options word
  map{|${1:var}| ${2} }

snippet sort
options word
  sort{|${1:x}, ${2:y}| ${2} }

snippet sort_by
options word
  sort_by{|${1:var}| ${2} }

snippet lambda
alias lam
options word
  ->(${1:#:args}){ ${2}}

snippet lambda-keyword
options word
  lambda{|${1:#:args}| ${2}}

snippet     main
options     head
  if __FILE__ == \$0
    ${0:TARGET}
  end

# This idiom is only for legacy ruby such as 1.9.3
snippet filedir-legacy-compatibility
alias __dir__
abbr File.dirname(...)
  File.dirname(File.expand_path(__FILE__))

snippet     glob
options     head
  Dir.glob(${1:'**/*'}) do |fname|
    ${0:TARGET}
  end

snippet     case
abbr        case ... when ... else ... end
options     head
  case ${1}
  when ${2}
    ${3}
  else
    ${4}
  end

snippet     class
alias cla
  class ${1:`substitute(expand('%:t:r:r:r'), '\v%(^(.)|_(.))', '\u\1\u\2', 'g')`}
    ${0}
  end

snippet     module
alias mod
  module ${1:`substitute(expand('%:t:r:r:r'), '\v%(^(.)|_(.))', '\u\1\u\2', 'g')`}
    ${0}
  end

# vim:set et ts=2 sts=2 sw=2 tw=0:
